total memory: 64kb = 65536b = 256 pages

resolution = 128x128 pixels
tile size  = 8x8     pixels
screen     = 16x16   tiles

background tiles = 256b = 1 page

sprites can only have 4 different colors, one of the colors is the transparency color, so in reality are 3 colors that you can use per sprite
one pixel of a sprite can be represented by two bits, pixel colors are just indexes in a palette.
1 byte  = 4 pixels
2 bytes = 0000000000000000
4 bytes = 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
tile/sprite = 8*8 pixels = 2*8 bytes = 16 bytes

max tiles/sprites = 128
mem tile/sprites  = 16 * 128 = 2048 = 8 pages

total colors = 16 (on hardware, can't be modiefied on memory)
palette = 4 colors (the first color will be used as the transparent color)
the palette needs 4 numbers that goes from 0 to 15, one nibble(4 bits) it's perfect for that

max palettes = 16
mem palettes = 16 / 2 = 8 bytes

the console will have a default font of 69 characters with 8x8 pixels
mem characters = 16 * 69 = 1104 bytes, round to the next page 1280

ZSRRRRRRRRRRRRRRRRBCCCCCVTTTTTTTT-----------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------

0xff

controller:
      ^
<- -> | | a b start select
        v
1 byte -> 0b00000000

cpu mem + cartridge = 0xffff(64kb)

cpu 0x0000 - 0x0bff
cpu 0xa000 - 0xffff

4 cores
0 -> cor transparent
1 2 3 -> cores da paleta

1 byte  = 4px
2 bytes = 8px

2 * 8 = 16

1 tile = 16 bytes

128 tiles
256 tiles bg
256 tiles fg

256 * 16 = 4096 = 0x1000
128 * 16 = 2048 = 2kb


00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00

8 background
8 sprites

16 cores:
	0x1 0x2 0x3 0x4 0x5 0x6 0x7 0x8 0x9 0xa 0xb 0xc 0xd 0xe 0xf

1 byte  = 2 indices das cores
2 bytes = 4 cores = 1 paleta

1.5 bytes = 3 cores
2   * 4 = 8  * 2 = 16 bytes
1.5 * 8 = 12 * 2 = 24 bytes
2   * 8 = 16 * 2 = 32 bytes



0000 0000 0000

0 - 63
0 - 7

64 + 8 = 72

0b00000000

0b100000
0b000

0b000000

100

0b00000000
00

16 * 16         = 256
2 * 16 * 16 / 8 = 64

10 * 16 * 16 = 2560 = 320

0 3
1 screen tile = 9 bits 
16 * 16 = 256 * 9 =

256 * 8
3 + 6 = 9

sprite:
	1 byte - x
	1 byte - y
	1 byte - tile
	2 bits - paleta
	1 bit  - flip x
	1 bit  - flip y
	1 bit  - below
	1 bit  - rot90

cpu:
	ram
	alu
	registers

rpu:
	ram (no access)
	registers
	colors
	screen

cartridge:
	rom

cpu ram + rpu ram + cartridge rom = 64kb


tiles attributes:
	bit (0, 1, 2) palette index
	bit 3         transparent
	bit 4         flipx
	bit 5         flipy
	bit 6         rot90
	bit 7         sprite ? below : unused
sprite tile: (4 bytes)
	position (x, y)  = 2 bytes
	tile index       = 1 byte
	attributes       = 1 byte
background tile: (1 byte)
	tile index = 1 byte
background attr: (1 byte)
	tile attributes = 1 byte

background:
	128 / 8 = 16
	16*16   = 256 bytes

sprites capacity: 64
64 * 4 = 256 bytes

0xf
1 byte  = 2 colors
2 bytes = 4 colors = 1 palette
2 * 4   = 8 bytes  = 4 palettes

memory layout:
		------------------|-------------------------|----------------
		address           |  usage                  | amount
		------------------|-------------------------|----------------
	cpu:                |                         |
		[0x0000 - 0x07ff] |  ram                    | 2kb
		[0x0800 - 0x08ff] |  stack                  | 256b
	rpu:                |                         |
		[0x0900 - 0x18ff] |  tiles background       | 1kb
		[0x1900 - 0x28ff] |  tiles sprites          | 1kb
		[0x2900 - 0x29ff] |  sprites                | 256b
		[0x2a00 - 0x2aff] |  background top-left    | 256b
		[0x2b00 - 0x2bff] |  background top-right   | 256b
		[0x2c00 - 0x2cff] |  background bot-left    | 256b
		[0x2e00 - 0x2eff] |  background bot-right   | 256b
		[0x2f00 - 0x2f07] |  pallete background     | 8b
		[0x2f08 - 0x2f0f] |  pallete sprites        | 8b
		[0x2f10 - 0x2f10] |  background control     | 1b
		[0x2f11 - 0x2f11] |  background x scrolling | 1b
		[0x2f12 - 0x2f12] |  background y scrolling | 1b
		[0x2f13 - 0x2f13] |  sprites amount         | 1b
	rom:                |                         |
		[0x2f14 - 0xfff7] |  general purpose        | ~52kb
		[0xfff8 - 0xfff9] |  vblank inter. addr     | 2b
		[0xfffa - 0xfffb] |  I/O inter. addr        | 2b
		[0xfffc - 0xfffd] |  reset inter. addr      | 2b
		[0xfffe - 0xffff] |  code start addr        | 2b

background control:
	bit 0, 1, 2 = bg-color
	bit 3       = bg-mirroring (0 horizontal, 1 vertical)

memory layout:
	[0x0000 - 0x00ff] zero page, used for cpu ram.
	[0x0100 - 0x01ff] stack or cpu ram
	[0x0200 - 0x11ff] more cpu ram
	[0x1200 - 0x12ff] background
	[0x1300 - 0x1307] palettes
	[0x1308 - 0x17ff] characters (read only)
	this memory is the rom loaded from the cartridge
	[0x1800 - 0x18ff] reset vector
	[0x1900 - 0x20ff] tiles/sprites
	[0x2100 - 0xfffd] general purpose memory
	[0xfffe - 0xffff] get the start address of the program

registers: x  y  z  f  s  p
           1  1  1  1  1  2

x -> general purpose 
y -> general purpose 
z -> general purpose/math operations
f -> flags
s -> stack pointer
p -> program pointer

instructions:
	0x00 -> nop -> no operation
	0x01 -> inx -> incremeant x by 1
	0x02 -> dex -> decremeant x by 1
	0x03 -> iny -> incremeant y by 1
	0x04 -> dey -> decremeant y by 1
	0x05 -> szr -> shifts z to the right by one bit
	0x06 -> szl -> shifts z to the left  by one bit
	0x07 -> shr -> shifts memory to the right by one bit
	0x08 -> shl -> shifts memory to the left  by one bit
	0x09 -> ror -> rotate memory to the right by one bit
	0x0a -> rol -> rotate memory to the left  by one bit
	0x0b -> rzr -> rotate z to the right by one bit
	0x0c -> rzl -> rotate z to the left  by one bit
	0x0d -> and -> and memory with z, the result is stored in z
	0x0e -> lor -> or  memory with z, the result is stored in z
	0x0f -> xor -> xor memory with z, the result is stored in z
	0x10 -> inc -> incremeants memory by 1
	0x11 -> dec -> incremeants memory by 1
	0x12 -> adc -> add memory to   z with carry
	0x13 -> sbc -> sub memory from z with carry
	0x14 -> ldz -> load memory into z
	0x15 -> stz -> stores z into memory
	0x16 -> ldx -> load memory into x
	0x17 -> stx -> stores x into memory
	0x18 -> ldy -> load memory into y
	0x19 -> sty -> stores y into memory
	0x1a -> zrx -> zero out x
	0x1b -> zry -> zero out y
	0x1c -> psh -> pushes z into the stack
	0x1d -> pop -> pops   the stack into z
	0x1e -> psf -> pushes f into the stack
	0x1f -> pof -> pops   the stack into f
	0x20 -> jts -> jump to subroutine
	0x21 -> jmp -> jump to memory location
	0x22 -> jeq -> jump if the previous operation is equal
	0x23 -> jle -> jump if the previous operation is less
	0x24 -> jgr -> jump if the previous operation is greater
	0x25 -> jne -> jump if the previous operation is not equal
	0x26 -> jnl -> jump if the previous operation is not less
	0x27 -> jng -> jump if the previous operation is not greater
	0x28 -> jpv -> jump if the overflow flag is set
	0x29 -> jnv -> jump if the overflow flag is not set
	0x2a -> jpn -> jump if the negative flag is set
	0x2b -> jnn -> jump if the negative flag is not set
	0x2c -> jpc -> jump if the carry    flag is not set
	0x2d -> jnc -> jump if the carry    flag is not set
	0x2e -> rfs -> return from subroutine
	0x2f -> rfi -> return from interrupt  
	0x30 -> tzy -> transfer z to y 
	0x31 -> tzx -> transfer z to x 
	0x32 -> tyz -> transfer y to z 
	0x33 -> tyx -> transfer y to x 
	0x34 -> txz -> transfer x to z 
	0x35 -> txy -> transfer x to y 
	0x36 -> szy -> swap z to y 
	0x37 -> szx -> swap z to x 
	0x38 -> sxy -> swap x to y 
	0x39 -> sec -> set carry     flag
	0x3a -> sev -> set overflow  flag
	0x3b -> clc -> clear carry     flag
	0x3c -> clv -> clear overflow  flag
	0x3d -> cmp -> compare memory with z
	0x3e -> cpx -> compare memory with x
	0x3f -> cpy -> compare memory with y
	0x40 -> adn -> and number with z, the result is stored in z
	0x41 -> orn -> or  number with z, the result is stored in z
	0x42 -> xrn -> xor number with z, the result is stored in z
	0x43 -> anc -> add number to   z with carry
	0x44 -> snc -> sub number from z with carry
	0x45 -> lnz -> load number into z
	0x46 -> lnx -> load number into x
	0x47 -> lny -> load number into y
	0x48 -> cpn -> compare number with z
	0x49 -> cnx -> compare number with x
	0x4a -> cny -> compare number with y

flags:
	C : carry
	Z : zero
	L : less
	N : negative
	V : overflow
